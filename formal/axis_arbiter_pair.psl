vunit axis_arbiter_pair_inst(axis_arbiter_pair(synthesis))
{
   -- set all declarations to run on clk
   default clock is rising_edge(clk_i);

   signal f_sampled_in0_a : boolean := false;
   signal f_sampled_in1_a : boolean := false;
   signal f_sampled_out_a : boolean := false;
   signal f_sampled_in0_b : boolean := false;
   signal f_sampled_in1_b : boolean := false;
   signal f_sampled_out_b : boolean := false;

   signal f_cnt_in0_a : natural;
   signal f_cnt_in1_a : natural;
   signal f_cnt_out_a : natural;
   signal f_cnt_in0_b : natural;
   signal f_cnt_in1_b : natural;
   signal f_cnt_out_b : natural;

   signal f_value_a : std_logic_vector(G_A_DATA_SIZE-1 downto 0);
   signal f_value_b : std_logic_vector(G_B_DATA_SIZE-1 downto 0);
   attribute anyconst : boolean;
   attribute anyconst of f_value_a : signal is true;
   attribute anyconst of f_value_b : signal is true;

   signal f_request0_active : boolean := false;
   signal f_request1_active : boolean := false;
   signal f_requestm_active : boolean := false;

   sampled_proc : process (clk_i)
   begin
     if rising_edge(clk_i) then
       if s0_a_valid_i = '1' and s0_a_ready_o = '1' then
         if s0_a_data_i = f_value_a then
           f_sampled_in0_a <= true;
         end if;
         f_cnt_in0_a <= f_cnt_in0_a + 1;
       end if;
       if s1_a_valid_i = '1' and s1_a_ready_o = '1' then
         if s1_a_data_i = f_value_a then
           f_sampled_in1_a <= true;
         end if;
         f_cnt_in1_a <= f_cnt_in1_a + 1;
       end if;
       if m_a_valid_o = '1' and m_a_ready_i = '1' then
         if m_a_data_o = f_value_a then
           f_sampled_out_a <= true;
         end if;
         f_cnt_out_a <= f_cnt_out_a + 1;
       end if;

       if s0_b_valid_i = '1' and s0_b_ready_o = '1' then
         if s0_b_data_i = f_value_b then
           f_sampled_in0_b <= true;
         end if;
         f_cnt_in0_b <= f_cnt_in0_b + 1;
       end if;
       if s1_b_valid_i = '1' and s1_b_ready_o = '1' then
         if s1_b_data_i = f_value_b then
           f_sampled_in1_b <= true;
         end if;
         f_cnt_in1_b <= f_cnt_in1_b + 1;
       end if;
       if m_b_valid_o = '1' and m_b_ready_i = '1' then
         if m_b_data_o = f_value_b then
           f_sampled_out_b <= true;
         end if;
         f_cnt_out_b <= f_cnt_out_b + 1;
       end if;

       if rst_i = '1' then
         f_sampled_in0_a <= false;
         f_sampled_in1_a <= false;
         f_sampled_out_a <= false;
         f_sampled_in0_b <= false;
         f_sampled_in1_b <= false;
         f_sampled_out_b <= false;
         f_cnt_in0_a <= 0;
         f_cnt_in1_a <= 0;
         f_cnt_out_a <= 0;
         f_cnt_in0_b <= 0;
         f_cnt_in1_b <= 0;
         f_cnt_out_b <= 0;
       end if;
     end if;
   end process sampled_proc;


   ------------------------------------------------
   -- PROPERTIES OF THE WISHBONE MASTER INTERFACE
   ------------------------------------------------

   -- AXI streaming output: Clear all requests after a reset
   f_master_reset_a : assert always {rst_i} |=> {not m_a_valid_o};
   f_master_reset_b : assert always {rst_i} |=> {not m_b_valid_o};

   -- AXI streaming output: Outputs must be stable during request
   f_master_stable_a : assert always {m_a_valid_o and not m_a_ready_i and not rst_i} |=> {stable(m_a_valid_o) and stable(m_a_data_o)};
   f_master_stable_b : assert always {m_b_valid_o and not m_b_ready_i and not rst_i} |=> {stable(m_b_valid_o) and stable(m_b_data_o)};

   -- AXI streaming output: Verify ordering
   f_master_ordering_a : assert always {f_sampled_out_a} |-> {f_sampled_in0_a or f_sampled_in1_a};
   f_master_ordering_b : assert always {f_sampled_out_b} |-> {f_sampled_in0_b or f_sampled_in1_b};

   -- AXI streaming input: Not both slaves may be active at the same time
   f_master_contention_a : assert always {not rst_i} |-> {s0_a_ready_o = '0' or s1_a_ready_o = '0'};
   f_master_contention_b : assert always {not rst_i} |-> {s0_b_ready_o = '0' or s1_b_ready_o = '0'};


   -----------------------------
   -- ASSUMPTIONS ABOUT INPUTS
   -----------------------------

   -- Require reset at startup.
   f_reset : assume {rst_i};


   --------------------------------------------
   -- COVER STATEMENTS TO VERIFY REACHABILITY
   --------------------------------------------

   -- AXI streaming output is asserted and then not asserted.
   f_request_a : cover {m_a_valid_o and not rst_i; not m_a_valid_o};
   f_request_b : cover {m_b_valid_o and not rst_i; not m_b_valid_o};
   f_cnt_ab : cover {f_cnt_out_a = 2 and f_cnt_out_b = 2 and rst_i = '0'};

} -- vunit axis_arbiter_pair_inst(axis_arbiter_pair(synthesis))

